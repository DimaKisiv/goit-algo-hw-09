# Результати тестування

| Amount  | Algorithm           | Time (seconds)                      |
|---------|---------------------|-------------------------------------|
| **113** | Greedy              | 0.000016                            |
| **113** | Dynamic Iterative    | 0.000495                            |
| **113** | Dynamic Recursive    | 0.003878                            |
| **113** | Dynamic Bottom-Up    | 0.000577                            |
| **534** | Greedy              | 0.000029                            |
| **534** | Dynamic Iterative    | 0.002711                            |
| **534** | Dynamic Recursive    | 0.021231                            |
| **534** | Dynamic Bottom-Up    | 0.003031                            |
| **19234**| Greedy              | 0.000534                            |
| **19234**| Dynamic Iterative    | 0.113609                            |
| **19234**| Dynamic Recursive    | 0.861514                            |
| **19234**| Dynamic Bottom-Up    | 0.118692                            |
| **192346**| Greedy              | 0.005844                            |
| **192346**| Dynamic Iterative    | 1.195103                            |
| **192346**| Dynamic Recursive    | maximum recursion depth exceeded   |
| **192346**| Dynamic Bottom-Up    | 1.290899                            |

## Висновки

- По результатам тесту жадібний алгоритм працює найшвидше, бо він найпростіший. Але за різних умов він знаходить не найоптимальніший результат.

- Ітеративний варіант динамічного алгоритму перебирає всі варіанти, через це працює повільніше, але може знайти найоптимальніше рішення.

- Рекурсивний варіант динамічного найповільніший та видає помилку надто великої глибини рекурсії при великих обчисленнях.

- Нижній підхід виконується трохи повільніше ніж звичайний ітеративний через те, що будує рішення знизу вгору та виконує додаткову роботу з масивами, хоча також гарантує оптимальне рішення.
